package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"strings"
)

var errNames = []string{
	"RcodeFormatError",
	"RcodeServerFailure",
	"RcodeNameError",
	"RcodeNotImplemented",
	"RcodeRefused",
	"RcodeYXDomain",
	"RcodeYXRrset",
	"RcodeNXRrset",
	"RcodeNotAuth",
	"RcodeNotZone",
	"RcodeBadSig",
	"RcodeBadKey",
	"RcodeBadTime",
	"RcodeBadMode",
	"RcodeBadName",
	"RcodeBadAlg",
	"RcodeBadTrunc",
	"RcodeBadCookie",
}

func errVar(rcode string) string {
	return "Err" + strings.ReplaceAll(strings.TrimPrefix(rcode, "Rcode"), "Error", "")
}

func fatalf(msg string, a ...interface{}) {
	_, _ = fmt.Fprintf(os.Stderr, "errsgen: "+msg+"\n", a...)
	os.Exit(1)
}

func main() {
	var pkg, out string
	flag.StringVar(&pkg, "pkg", "errors", "package to use")
	flag.StringVar(&out, "out", "errors.go", "output filename")
	flag.Parse()

	var code bytes.Buffer
	_, _ = fmt.Fprintln(&code, "// Code generated by errsgen; DO NOT EDIT. ")
	_, _ = fmt.Fprintf(&code, "package %s\n", pkg)

	_, _ = fmt.Fprintln(&code, "import (")
	_, _ = fmt.Fprintln(&code, `"errors"`)
	_, _ = fmt.Fprintln(&code, `"github.com/miekg/dns"`)
	_, _ = fmt.Fprintln(&code, ")")

	_, _ = fmt.Fprintln(&code, "var (")
	for _, errName := range errNames {
		errCode := fmt.Sprintf("dns.%s", errName)
		_, _ = fmt.Fprintf(&code,
			"%s = &DNSError{RCode: %s, Nested: errors.New(dns.RcodeToString[%s])}\n",
			errVar(errName), errCode, errCode,
		)
	}
	_, _ = fmt.Fprintln(&code, ")")

	formatted, err := format.Source(code.Bytes())
	if err != nil {
		fatalf("parse generated code: %v", err)
	}

	err = os.WriteFile(out, formatted, 0o644)
	if err != nil {
		fatalf("save code: %v", err)
	}
}
